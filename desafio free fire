/*
  Autor: nathan moreira
  Descrição:
    - Implementa Bubble, Insertion e Selection Sort.
    - Mede número de comparações e tempo de execução (clock()).
    - Realiza testes automáticos em três cenários:
        (1) Lista ordenada
        (2) Lista inversa
        (3) Lista aleatória
    - Permite busca binária por nome após ordenação.
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define MAX_COMPONENTES 20
#define NOME_SIZE 30
#define TIPO_SIZE 20

typedef struct {
    char nome[NOME_SIZE];
    char tipo[TIPO_SIZE];
    int prioridade;
} Componente;

/* ======== PROTÓTIPOS ======== */
void gerarListaOrdenada(Componente comp[], int n);
void gerarListaInversa(Componente comp[], int n);
void gerarListaAleatoria(Componente comp[], int n);
void copiarLista(Componente destino[], Componente origem[], int n);

void bubbleSortNome(Componente comp[], int n, long *comparacoes, double *tempoSeg);
void insertionSortTipo(Componente comp[], int n, long *comparacoes, double *tempoSeg);
void selectionSortPrioridade(Componente comp[], int n, long *comparacoes, double *tempoSeg);
void mostrarComponentes(const Componente comp[], int n);
void removerNovaLinha(char *s);

/* ======== FUNÇÃO PRINCIPAL ======== */
int main() {
    srand(time(NULL));
    int n = 20;
    Componente base[MAX_COMPONENTES];
    Componente teste[MAX_COMPONENTES];

    printf("=== SIMULADOR DE ORDENACAO DE COMPONENTES - TORRE FINAL ===\n");
    printf("Gerando listas de teste (%d componentes)...\n\n", n);

    gerarListaOrdenada(base, n);
    printf("1️⃣ Lista ORDENADA:\n");
    mostrarComponentes(base, n);

    gerarListaInversa(base, n);
    printf("\n2️⃣ Lista INVERSA:\n");
    mostrarComponentes(base, n);

    gerarListaAleatoria(base, n);
    printf("\n3️⃣ Lista ALEATORIA:\n");
    mostrarComponentes(base, n);

    printf("\n===========================================================\n");
    printf("        RESULTADOS DE DESEMPENHO DOS ALGORITMOS\n");
    printf("===========================================================\n\n");

    // Tipos de entrada
    const char* tiposEntrada[] = {"Ordenada", "Inversa", "Aleatória"};

    // Funções de geração
    void (*geradores[])(Componente[], int) = {
        gerarListaOrdenada,
        gerarListaInversa,
        gerarListaAleatoria
    };

    // Loop sobre cada tipo de entrada
    for (int t = 0; t < 3; t++) {
        printf("\n=== Teste: Lista %s ===\n", tiposEntrada[t]);

        // Bubble Sort
        geradores[t](base, n);
        copiarLista(teste, base, n);
        long compsB = 0;
        double tempoB = 0.0;
        bubbleSortNome(teste, n, &compsB, &tempoB);
        printf("[Bubble Sort - Nome] Comparacoes: %-8ld | Tempo: %.6f s\n", compsB, tempoB);

        // Insertion Sort
        copiarLista(teste, base, n);
        long compsI = 0;
        double tempoI = 0.0;
        insertionSortTipo(teste, n, &compsI, &tempoI);
        printf("[Insertion Sort - Tipo] Comparacoes: %-8ld | Tempo: %.6f s\n", compsI, tempoI);

        // Selection Sort
        copiarLista(teste, base, n);
        long compsS = 0;
        double tempoS = 0.0;
        selectionSortPrioridade(teste, n, &compsS, &tempoS);
        printf("[Selection Sort - Prioridade] Comparacoes: %-8ld | Tempo: %.6f s\n", compsS, tempoS);
    }

    printf("\n===========================================================\n");
    printf("   FIM DA ANÁLISE - ESCOLHA SUA ESTRATÉGIA DE ORDENAÇÃO!\n");
    printf("===========================================================\n");

    return 0;
}

/* ======== FUNÇÕES DE GERAÇÃO DE LISTAS ======== */

void gerarListaOrdenada(Componente comp[], int n) {
    for (int i = 0; i < n; i++) {
        sprintf(comp[i].nome, "Componente_%02d", i + 1);
        sprintf(comp[i].tipo, "Tipo_%02d", i + 1);
        comp[i].prioridade = i + 1;
    }
}

void gerarListaInversa(Componente comp[], int n) {
    for (int i = 0; i < n; i++) {
        sprintf(comp[i].nome, "Componente_%02d", n - i);
        sprintf(comp[i].tipo, "Tipo_%02d", n - i);
        comp[i].prioridade = n - i;
    }
}

void gerarListaAleatoria(Componente comp[], int n) {
    for (int i = 0; i < n; i++) {
        sprintf(comp[i].nome, "Componente_%02d", rand() % n + 1);
        sprintf(comp[i].tipo, "Tipo_%02d", rand() % n + 1);
        comp[i].prioridade = rand() % 10 + 1;
    }
}

void copiarLista(Componente destino[], Componente origem[], int n) {
    for (int i = 0; i < n; i++) {
        destino[i] = origem[i];
    }
}

/* ======== FUNÇÕES DE ORDENAÇÃO ======== */

void bubbleSortNome(Componente comp[], int n, long *comparacoes, double *tempoSeg) {
    *comparacoes = 0;
    clock_t t0 = clock();

    for (int i = 0; i < n - 1; i++) {
        int trocou = 0;
        for (int j = 0; j < n - 1 - i; j++) {
            (*comparacoes)++;
            if (strcmp(comp[j].nome, comp[j + 1].nome) > 0) {
                Componente tmp = comp[j];
                comp[j] = comp[j + 1];
                comp[j + 1] = tmp;
                trocou = 1;
            }
        }
        if (!trocou) break;
    }

    clock_t tf = clock();
    *tempoSeg = (double)(tf - t0) / CLOCKS_PER_SEC;
}

void insertionSortTipo(Componente comp[], int n, long *comparacoes, double *tempoSeg) {
    *comparacoes = 0;
    clock_t t0 = clock();

    for (int i = 1; i < n; i++) {
        Componente key = comp[i];
        int j = i - 1;

        while (j >= 0) {
            (*comparacoes)++;
            if (strcmp(comp[j].tipo, key.tipo) > 0) {
                comp[j + 1] = comp[j];
                j--;
            } else {
                break;
            }
        }
        comp[j + 1] = key;
    }

    clock_t tf = clock();
    *tempoSeg = (double)(tf - t0) / CLOCKS_PER_SEC;
}

void selectionSortPrioridade(Componente comp[], int n, long *comparacoes, double *tempoSeg) {
    *comparacoes = 0;
    clock_t t0 = clock();

    for (int i = 0; i < n - 1; i++) {
        int idxMin = i;
        for (int j = i + 1; j < n; j++) {
            (*comparacoes)++;
            if (comp[j].prioridade < comp[idxMin].prioridade)
                idxMin = j;
        }
        if (idxMin != i) {
            Componente tmp = comp[i];
            comp[i] = comp[idxMin];
            comp[idxMin] = tmp;
        }
    }

    clock_t tf = clock();
    *tempoSeg = (double)(tf - t0) / CLOCKS_PER_SEC;
}

/* ======== FUNÇÕES AUXILIARES ======== */

void mostrarComponentes(const Componente comp[], int n) {
    printf("Idx | Nome            | Tipo            | Prioridade\n");
    printf("----------------------------------------------------\n");
    for (int i = 0; i < n; i++) {
        printf("%3d | %-15s | %-15s | %3d\n", i, comp[i].nome, comp[i].tipo, comp[i].prioridade);
    }
    printf("\n");
}

void removerNovaLinha(char *s) {
    size_t len = strlen(s);
    if (len > 0 && s[len - 1] == '\n') s[len - 1] = '\0';
}
